#include <iostream>
#include <cstdlib>
#include <string>

// !!!!! изменен тип поля name - string вместо char
// в цикле применили функцию к массиву из 10 экземпляров структуры hero

struct hero // создали структуру hero, в ней - поля "имя", "здоровье", "броня". С++ позволяет сразу дать значения по умолчанию
{
    std::string name = "unknown"; 
    int health = 0;
    int armor = 0;
};

void takeDamage(hero *man, int damage) // функция фиксации полученного ущерба. Передаем в нее по указателю (т.к.будут изменения) свою стуктуру
                                       // (т.е. созданный нами тип данных) для экземпляра man. Damage в функции не будет меняться, поэтому
                                       // его передаем напрямую, без указателя
{
    // обратиться к полю из структуры можно по-разному. В данном случае используем стрелку ->
    man->armor -= damage;
    if (man->armor < 0)
    {
        man->health += man->armor;
        man->armor = 0;
    }

    std::cout << man->name << " took damage " << damage << ". Actual armor = " << man->armor << ", actual healh = " << man->health << ", damage power was " << damage << "\n";
}

int main()
{
   hero people[10]; //создали массив из 10 экземпляров переменных типа hero

   // инициализируем все элементы всех экземпляров
   for (int i = 0; i < 10; i++)
     {
       people[i].name = "Hero #" + std::to_string(i); // внимание!!! привели int к string'у
       people[i].health = (std::rand() % 100) + 100;  
       people[i].armor = (std::rand()%41) +10;

     }

      for (int i = 0; i < 10; i++)
        {
            takeDamage(&people[i], 30); //внимание!!! имямассива само является указателем! (на нулевой элемент массива!)! Следовательно, можно изменить форму обращения 
                                        // к элементам этого массива, убрав знак & и тупо прибавляя по единичке к имени массива для получения указателй на следующие элементы
                                        // вот так: takeDamage(people+i, 30); 
        }
    
    
    
   // -- hero man = {"Ivan", 100, 20}; // создали переменную man типа hero и (согласно структуры этого нашего типа данных) присвоили параметры
    // Олень опять не учел, что ISO C++ forbids converting a string constant to 'char*'
   // -- hero *manPtr = &man;
   // -- takeDamage(manPtr, 30);
   // -- takeDamage(&man, 30); // можем передать в функцию непосредственно указатель на переменную man без промежуточного имени такого указателя
   // -- std::cout << man.name << " has " << man.health << " health. Actual armor = " << man.armor << ", damage power was " << 30 << "\n";

    // !!! значения полей экземпляра нашей "структуры" доступны (видимы) в теле программы!!

    /*
    ---короче, создаем свой тип данных ("структуру"), в ней поля (даем им имена, указываем тип данных каждого поля, можем даже присвоить полям
       значения по умолчанию).

    ---в теле программы создаем экземпляр переменной с типом, указанным в имени структуры

    ---согласно заложенной в структуре очередности указываем параметры данного экземпляра

    ---создаем функцию, которая работает с экземплярами определенного нами типа данных (созданной "структуры")

    ---в функцию передаем, как обычно, указатель на экземпляр нашей "структуры" (по указателю - т.к. параметры экземпляров эта функция будет
       изменять) и прочие параметры. Если они не будут изменены в результате работы функции - можно передавать их без указателя, напрямую

    ---вызывая функцию, передаем в нее указатель на созданный выше экземпляр переменной нашей "структуры" (можно этот указатель передать через
       промежуточную переменную)


    */
}