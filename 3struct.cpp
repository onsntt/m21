#include <iostream>
#include <cstdlib>
#include <string>
// передать значения в функцию можно не только по указателям, но и по ссылкам:

// !!!!! изменен тип поля name - string вместо char
// в цикле применили функцию к массиву из 10 экземпляров структуры hero

struct hero // создали структуру hero, в ней - поля "имя", "здоровье", "броня". С++ позволяет сразу дать значения по умолчанию
{
    std::string name = "unknown";
    int health = 0;
    int armor = 0;
};

void takeDamage(hero& man, int damage) // передаем теперь параметр по ссылке (& после объявления типа)
                                       // переменные - ссылки используются так же, как и просто переменные. 
                                       // чтобы добраться к полям придется использовать "через точку" вместо "стрелки"

{
    // обратиться к полю  структуры можно по-разному. В данном случае используем не стрелку ->, а точку.
    man.armor -= damage;
    if (man.armor < 0)
    {
        man.health += man.armor;
        man.armor = 0;
    }

    std::cout << man.name << " took damage " << damage << ". Actual armor = " << man.armor << ", actual healh = " << man.health << ", damage power was " << damage << "\n";
}

int main()
{
    hero people[10]; // создали массив из 10 экземпляров переменных типа hero

    // инициализируем все элементы всех экземпляров
    for (int i = 0; i < 10; i++)
    {
        people[i].name = "Hero #" + std::to_string(i); // внимание!!! привели int к string'у
        people[i].health = (std::rand() % 100) + 100;
        people[i].armor = (std::rand() % 41) + 10;
    }

    for (int i = 0; i < 10; i++)
    {
        takeDamage(people[i], 30); // если передаем параметры в функцию по ссылке, вместо указателя &people[i] в вызове указываем саму переменную
    }                              //таким образом в функцию передается сам элемент, а не указатель на него
                                   // внимание!!! в функцию уходит ссылка на элемент! Если бы мы передавали в функцию takeDamage параметр не по ссылке,
                                   // а по значению (т.е. не "void takeDamage(hero& man, int damage)" а так: void takeDamage(hero man, int damage))
                                   // то в функцию передавалась бы не сама переменная man, а ее копия (которая за пределами функции не живет)

    // -- hero man = {"Ivan", 100, 20}; // создали переменную man типа hero и (согласно структуры этого нашего типа данных) присвоили параметры
    // Олень опять не учел, что ISO C++ forbids converting a string constant to 'char*'
    // -- hero *manPtr = &man;
    // -- takeDamage(manPtr, 30);
    // -- takeDamage(&man, 30); // можем передать в функцию непосредственно указатель на переменную man без промежуточного имени такого указателя
    // -- std::cout << man.name << " has " << man.health << " health. Actual armor = " << man.armor << ", damage power was " << 30 << "\n";

    // !!! значения полей экземпляра нашей "структуры" доступны (видимы) в теле программы!!

    /*
    ---короче, создаем свой тип данных ("структуру"), в ней поля (даем им имена, указываем тип данных каждого поля, можем даже присвоить полям
       значения по умолчанию).

    ---в теле программы создаем экземпляр переменной с типом, указанным в имени структуры

    ---согласно заложенной в структуре очередности указываем параметры данного экземпляра

    ---создаем функцию, которая работает с экземплярами определенного нами типа данных (созданной "структуры")

    ---в функцию передаем, как обычно, указатель на экземпляр нашей "структуры" (по указателю - т.к. параметры экземпляров эта функция будет
       изменять) и прочие параметры. Если они не будут изменены в результате работы функции - можно передавать их без указателя, напрямую

    ---вызывая функцию, передаем в нее указатель на созданный выше экземпляр переменной нашей "структуры" (можно этот указатель передать через
       промежуточную переменную)


    */
}