#include <iostream>

int main()
{

    // массив символов может интерпретироваться как строка, значит, указатель на значения типа char тоже может интерпретироваться как строка:

    char hello[]{"123hello"}; // создаем массив символов с именем hello и инициализируем его набором символов 123hello
    char *phello{hello};      // создаем указатель на массив hello и называем его phello
    std::cout << phello << std::endl; // 123hello, а не адрес первого элемента!!! Указатель на значения типа char возвращает саму строку!

    std::cout << *phello << std::endl; // разыменование указателя на массив символов char вернет нулевой элемент - 1
    std::cout << *(phello+1) << std::endl; // разыменование указателя на массив символов char +1 вернет следующий элемент массива - 2
    std::cout << *(phello + 3) << std::endl; // разыменование указателя на массив символов char +3 вернет третий элемент массива - h

    std::cout << (void *)phello << std::endl; // если нужно получить и вывести на консоль адрес указателя, то его надо преобразовать к типу void*:

    // указатель типа char  может интерпретироваться как строка. Следовательно, мы можем написать следующим образом:

    //char *pvata{"vata"};
    /*
    Следует учитывать, что строковые литералы в С++ рассматриваются как константы, 
    поэтому такое определение указателя может при компиляции вызвать как минимум предупреждение, 
    а попытка изменить элементы строки через указатель - к ошибке компиляции.
    Правильно будет при определении указателя на строку определять указатель как указатель на константу:
    */
    const char *pvata{"vata"};
    std::cout << pvata << std::endl;
}